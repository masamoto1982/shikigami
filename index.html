<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>shikigami</title>
    <style>
	:root {
    /* カラーパレット (元のスタイルシートの色を定義) */
    --color-body-bg: #f0f0f0;
    --color-article-bg: #ffffff;
    --color-section-border: #a0a0a0; /* Medium Grey */
    --color-border-light: #cccccc; /* Light Grey */
    --color-surface-light: #f8f8f8; /* Very Light Grey */
    --color-output-executed-bg: #d1fae5; /* Light Green */
    --color-dot-numeric-bg: #fee2e2; /* Light Pink-Red */
    --color-dot-numeric-text: #ef4444; /* Red */
    --color-dot-word-bg: #dbeafe; /* Light Blue */
    --color-dot-word-text: #3b82f6; /* Blue */
    --color-dot-detected-bg: #fca5a5; /* Pink */
    --color-special-button-bg: #e5e7eb; /* Light Grey-Blue */
    --color-special-button-delete-space-bg: var(--color-surface-light);
    --color-special-button-long-pressed-bg: #fde68a; /* Light Yellow */
    --color-special-button-combined-pressed-bg: #93c5fd; /* Light Blue */
    --color-execute-button-bg: var(--color-dot-word-text); /* Use the same blue as word dot text */
    --color-execute-button-hover-bg: #2563eb; /* Darker Blue */
    --color-execute-button-active-bg: #1d4ed8; /* Even Darker Blue */
    --color-debug-panel-bg: #f8fafc; /* Very Light Blue-Grey */
    --color-debug-panel-border: #cbd5e1; /* Light Blue-Grey Border */
    --color-debug-output-bg: #f1f5f9; /* Light Blue-Grey */
    --color-text-muted: #a0a0a0; /* Muted Text Color (used for h2) */
    --color-dot-text-muted: #aaa; /* Even Lighter Grey for default dot text */

    /* スペーシング */
    --space-xs: 5px;
    --space-sm: 8px;
    --space-md: 10px;
    --space-lg: 20px;

    /* サイズ */
    --size-max-width-article: 800px;
    --size-min-height-input-output: 80px;
    --size-height-input-output-desktop: 500px; /* Desktop default */
    --size-max-height-input-output: 300px;
    --size-min-height-upper-half: 120px;
    --size-dot: 45px;
    --size-special-button-width: 100px;
    --size-special-button-height: 45px;
    --size-execute-button-width: 100px;
    --size-min-width-control-label: 120px;
    --size-min-width-value-display: 40px;
    --size-max-height-debug-output: 150px;
    --size-feedback-circle: 80px;
    --size-feedback-text: 32px;

    /* ボーダーラディウス */
    --radius-sm: 4px;
    --radius-md: 5px;
    --radius-lg: 10px;
    --radius-round: 50%;
}


/* Apply border-box sizing globally */
*,
*::before,
*::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    overscroll-behavior: none;
    text-align: center;
    background-color: var(--color-body-bg);
    font-family: sans-serif;
}

/* Main layout container */
article {
    width: 100%;
    max-width: var(--size-max-width-article);
    display: flex;
    flex-direction: column;
    margin: 0 auto;
    background-color: var(--color-article-bg);
    padding: var(--space-md);
    text-align: left;
}

h1 {
    text-align: center;
}


h2 {
    text-align: left;
    color: var(--color-text-muted); /* Original #ccc, mapping to a muted text var */
}

section {
    border: 2px dotted var(--color-section-border);
    padding: var(--space-md);
    margin: var(--space-md) 0 var(--space-md) 0;
}

section:last-child {
    margin-bottom: 0;
}

/* Style for textarea and input */
#output,
#txt-input {
    width: 100%;
    padding: var(--space-sm);
    border: 1px solid var(--color-border-light);
    border-radius: var(--radius-sm);
    display: block;
    margin-top: var(--space-xs);
}


#output {
    resize: vertical;
    min-height: var(--size-min-height-input-output);
    height: var(--size-height-input-output-desktop); /* Desktop default height */
    max-height: var(--size-max-height-input-output);
    background-color: var(--color-surface-light);
    transition: background-color 0.3s;
    overflow-y: auto;
}

#txt-input {
    resize: vertical;
    min-height: var(--size-min-height-input-output);
    height: var(--size-height-input-output-desktop); /* Desktop default height */
    max-height: var(--size-max-height-input-output);
    transition: background-color 0.3s;
    overflow-y: auto;
    font-family: monospace;
}

#output.executed {
    background-color: var(--color-output-executed-bg);
    transition: background-color 0.3s;
}

/* Input areas container */
#input-container {
    display: flex;
    flex-direction: column;
}

#upper-half {
    flex: 1;
    min-height: var(--size-min-height-upper-half);
}


#d2d-input {
    position: relative;
    user-select: none;
    margin-top: var(--space-xs);
}

#dot-grid {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    margin-bottom: var(--space-md);
    align-items: center;
}

.dot-row {
    display: flex;
    justify-content: center;
    gap: var(--space-md);
}

.dot {
    width: var(--size-dot);
    height: var(--size-dot);
    border-radius: var(--radius-round);
    border: 1px solid var(--color-border-light);
    background-color: var(--color-surface-light);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: bold;
    color: var(--color-dot-text-muted); /* Original #aaa */
    cursor: pointer;
    position: relative;
    transition: background-color 0.1s;
    flex-shrink: 0;
}

.dot.numeric {
    background-color: var(--color-dot-numeric-bg);
    color: var(--color-dot-numeric-text);
    font-size: 16px;
}

.dot.word-dot {
    background-color: var(--color-dot-word-bg);
    color: var(--color-dot-word-text);
    font-size: 12px;
    overflow: hidden;
    text-align: center;
    line-height: 1.2;
}

.dot.detected {
    background-color: var(--color-dot-detected-bg);
    border-color: var(--color-dot-numeric-text); /* Original #ef4444 */
}

#special-row {
    display: flex;
    justify-content: center;
    gap: var(--space-md);
    margin-top: var(--space-md);
}

.special-button {
    width: var(--size-special-button-width);
    height: var(--size-special-button-height);
    border-radius: var(--radius-lg);
    border: 1px solid var(--color-border-light);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    background-color: var(--color-special-button-bg);
    flex-shrink: 0;
    transition: transform 0.1s, background-color 0.1s;
}

.special-button.delete {
    background-color: var(--color-special-button-delete-space-bg);
}

.special-button.space {
    background-color: var(--color-special-button-delete-space-bg);
}

.special-button.long-pressed {
    background-color: var(--color-special-button-long-pressed-bg);
    transform: scale(0.95);
}

.special-button.combined-pressed {
    background-color: var(--color-special-button-combined-pressed-bg);
    transform: scale(0.95);
}

#special-row .dot.numeric {
     flex-shrink: 0;
     /* Note: original CSS had no specific styles for numeric dots within special-row,
              so it inherits the general .dot.numeric style */
}

#line-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
}

/* Execute Button Style */
#execute-button {
    display: block;
    width: var(--size-execute-button-width);
    padding: var(--space-md);
    margin: var(--space-md) auto;  /* 中央寄せ */
    background-color: var(--color-execute-button-bg);
    color: white; /* Original was white, keep as literal or define --color-white */
    border: none;
    border-radius: var(--radius-sm);
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s;
}

#execute-button:hover {
    background-color: var(--color-execute-button-hover-bg);
}

#execute-button:active {
    background-color: var(--color-execute-button-active-bg);
}

/* Debug Panel Styles */
#debug-panel {
    margin-top: var(--space-lg);
    padding: var(--space-md);
    background-color: var(--color-debug-panel-bg);
    border: 1px solid var(--color-debug-panel-border);
    border-radius: var(--radius-md);
}

.control-container {
    display: flex;
    align-items: center;
    margin: var(--space-sm) 0;
}

.control-container label {
    min-width: var(--size-min-width-control-label);
}

.control-container input[type="range"] {
    flex-grow: 1;
    margin: 0 var(--space-md);
}

.value-display {
    min-width: var(--size-min-width-value-display);
    text-align: right;
}

.debug-output {
    margin-top: var(--space-md);
    padding: var(--space-md);
    background-color: var(--color-debug-output-bg);
    border-radius: var(--radius-sm);
    max-height: var(--size-max-height-debug-output);
    overflow-y: auto;
    font-family: monospace;
    font-size: 12px;
}

.recognition-feedback {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.9); /* Original rgba */
    border-radius: var(--radius-round);
    width: var(--size-feedback-circle);
    height: var(--size-feedback-circle);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: var(--size-feedback-text);
    font-weight: bold;
    color: var(--color-dot-word-text); /* Original #3b82f6 */
    animation: fadeOut 0.8s ease-out forwards;
    pointer-events: none;
}

@keyframes fadeOut {
    0% {
        opacity: 1;
    }
    70% {
        opacity: 1;
    }
    100% {
        opacity: 0;
    }
}

/* Responsive layout */
@media (max-width: 768px) {

    #mobile-container {
        display: flex;
        flex-direction: column;
        /* Assuming 80px header/footer space, adjust if needed */
        height: calc(100vh - 80px);
    }

    #upper-half {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .input-section,
    .output-section {
        flex: 1;
        transition: transform 0.3s ease;
        width: 100%;
    }

    #output,
    #txt-input {
        /* Adjusted height for mobile */
        height: 200px; /* Keep 200px as it was in the original media query */
        /* min-height: 6rem; was only on #txt-input in original mobile query */
    }

    #txt-input {
         min-height: 6rem; /* Original mobile specific min-height */
    }


    .hide {
        display: none;
    }

    #d2d-section {
        height: 50vh;
        min-height: var(--size-min-height-d2d-mobile); /* Use variable for 300px */
        touch-action: auto; /* モバイルでのタッチ操作を有効化 */
    }

    #debug-panel {
        display: none;
    }

    /* モバイル用にタッチ操作を確実に有効化 */
    body,
    #d2d-input,
    .dot,
    .special-button {
        touch-action: auto;
    }

    /* モバイルでのタッチ操作時のハイライト無効化 */
    * {
        -webkit-tap-highlight-color: transparent;
    }
}

@media (min-width: 769px) {
    #mobile-container {
        display: block;
    }

    .input-section,
    .output-section {
        display: block;
    }

    .hide {
        display: block;
    }

    /* Restore desktop heights if they were overridden in mobile */
    #output,
    #txt-input {
         height: var(--size-height-input-output-desktop);
    }
}
    </style>
</head>

<body>
    <article>
        <h1>shikigami ver.202504201217</h1>

        <div id="mobile-container">
            <div id="upper-half">
                <section id="output-section" class="output-section hide">
                    <h2>output</h2>
                    <textarea id="output" readonly></textarea>
                </section>

                <section id="text-section" class="input-section">
                    <h2>txt-input</h2>
                    <textarea id="txt-input" rows="4" placeholder="Enter shikigami code..."></textarea>
                    <button id="execute-button">実行</button>
                </section>
            </div>

            <section id="d2d-section">
                <h2>d2d-input</h2>
                <div id="d2d-input">
                    <div id="dot-grid"></div>
                    <div id="special-row"></div>
                    <canvas id="line-canvas"></canvas>
                </div>
            </section>
        </div>
    </article>

    <script>
        // --- Configuration Parameters ---
        const CONFIG = {
            debug: true,
            sensitivity: {
                hitRadius: 22,
                minSwipeDistance: 5,
                debounceTime: 50,
            },
            timing: {
                multiStrokeTimeout: 700,
                longPressDuration: 500,
                strokeCooldown: 100,
            },
            layout: {
                dotSize: 45,
                dotGap: 10,
                gridRows: 5,
                gridCols: 5,
            },
            visual: {
                lineWidth: 3,
                lineColor: '#ef4444',
                detectedColor: '#fca5a5',
            }
        };

        // --- Fraction Class Definition ---
        class Fraction {
            constructor(numerator, denominator = 1) {
                if (typeof numerator !== 'number' || typeof denominator !== 'number') {
                    throw new Error("Numerator and denominator must be numbers.");
                }
                if (denominator === 0) {
                    throw new Error("Division by zero: Denominator cannot be zero.");
                }
                if (!Number.isInteger(numerator) || !Number.isInteger(denominator)) {
                    console.warn("Fraction created with non-integer values. Consider using integers for precision.");
                }
                const commonDivisor = this.gcd(Math.abs(numerator), Math.abs(denominator));
                const sign = (denominator < 0) ? -1 : 1;
                this.numerator = sign * (numerator / commonDivisor);
                this.denominator = Math.abs(denominator / commonDivisor);
            }

            gcd(a, b) {
                a = Math.abs(Math.round(a));
                b = Math.abs(Math.round(b));
                while (b !== 0) { [a, b] = [b, a % b]; }
                return a;
            }
            add(other) {
                if (!(other instanceof Fraction)) throw new Error("Can only add Fraction objects.");
                const newNumerator = this.numerator * other.denominator + other.numerator * this.denominator;
                const newDenominator = this.denominator * other.denominator;
                return new Fraction(newNumerator, newDenominator);
            }
            subtract(other) {
                if (!(other instanceof Fraction)) throw new Error("Can only subtract Fraction objects.");
                const newNumerator = this.numerator * other.denominator - other.numerator * this.denominator;
                const newDenominator = this.denominator * other.denominator;
                return new Fraction(newNumerator, newDenominator);
            }
            multiply(other) {
                if (!(other instanceof Fraction)) throw new Error("Can only multiply Fraction objects.");
                const newNumerator = this.numerator * other.numerator;
                const newDenominator = this.denominator * other.denominator;
                return new Fraction(newNumerator, newDenominator);
            }
            divide(other) {
                if (!(other instanceof Fraction)) throw new Error("Can only divide Fraction objects.");
                if (other.numerator === 0) throw new Error("Division by zero: Cannot divide by a zero fraction.");
                const newNumerator = this.numerator * other.denominator;
                const newDenominator = this.denominator * other.numerator;
                return new Fraction(newNumerator, newDenominator);
            }
            equals(other) {
                if (!(other instanceof Fraction)) return false;
                return this.numerator === other.numerator && this.denominator === other.denominator;
            }
            lessThan(other) {
                if (!(other instanceof Fraction)) throw new Error("Can only compare Fraction objects.");
                return this.numerator * other.denominator < other.numerator * this.denominator;
            }
            greaterThan(other) {
                if (!(other instanceof Fraction)) throw new Error("Can only compare Fraction objects.");
                return this.numerator * other.denominator > other.numerator * this.denominator;
            }
            toString() {
                return this.denominator === 1 ? `${this.numerator}` : `${this.numerator}/${this.denominator}`;
            }
            toNumber() {
                return this.numerator / this.denominator;
            }
        }

        // --- 自動フォーマット機能 ---
        const codeFormatter = {
            indentSize: 4,
            
            format: function(code) {
                if (!code || typeof code !== 'string') return code;
                
                const lines = code.split('\n');
                const formattedLines = [];
                let indentLevel = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    
                    // コメント行はトリムのみ
                    if (line.startsWith('#')) {
                        formattedLines.push(' '.repeat(indentLevel * this.indentSize) + line);
                        continue;
                    }
                    
                    // 閉じ括弧があれば、先にインデントを減らす
                    if (line.includes('}')) {
                        const closingBraceIndex = line.indexOf('}');
                        if (closingBraceIndex === 0) {
                            indentLevel = Math.max(0, indentLevel - 1);
                        }
                    }
                    
                    // 現在のインデントレベルに合わせてスペースを追加
                    formattedLines.push(' '.repeat(indentLevel * this.indentSize) + line);
                    
                    // 開き括弧があれば、次の行からインデントを増やす
                    if (line.includes('{')) {
                        indentLevel++;
                    }
                }
                
                return formattedLines.join('\n');
            },
            
            setupAutoFormat: function(inputElement) {
                if (!inputElement) return;
                
                let timeout = null;
                const delay = 500; // フォーマット実行の遅延（ms）
                
                inputElement.addEventListener('input', () => {
                    clearTimeout(timeout);
                    
                    // 入力後、一定時間経過後にフォーマット実行
                    timeout = setTimeout(() => {
                        const cursorPos = inputElement.selectionStart;
                        const textBeforeCursor = inputElement.value.substring(0, cursorPos);
                        const textAfterCursor = inputElement.value.substring(cursorPos);
                        
                        // フォーマット適用
                        const formattedText = this.format(inputElement.value);
                        inputElement.value = formattedText;
                        
                        // カーソル位置の再調整（簡易版）
                        try {
                            const newCursorPos = Math.min(
                                cursorPos + (formattedText.length - (textBeforeCursor.length + textAfterCursor.length)), 
                                formattedText.length
                            );
                            inputElement.setSelectionRange(newCursorPos, newCursorPos);
                        } catch (e) {
                            console.error('カーソル位置調整エラー:', e);
                        }
                    }, delay);
                });
                
                // フォーカスを得たときにもフォーマットを適用
                inputElement.addEventListener('focus', () => {
                    inputElement.value = this.format(inputElement.value);
                });
            }
        };

        // --- shikigami Interpreter ---
        const shikigamiInterpreter = {
            // 変数とその値を保持する環境
            environment: {
                global: {},
                current: null
            },
            
            // 標準関数の定義
            standardFunctions: {
                PRINT: (value) => {
                    console.log(value);
                    return value;
                },
                RANGE: (start, end) => {
                    const result = [];
                    let i = start instanceof Fraction ? start.toNumber() : start;
                    let e = end instanceof Fraction ? end.toNumber() : end;
                    for (let j = i; j <= e; j++) {
                        result.push(new Fraction(j));
                    }
                    return result;
                },
                MAP: (array, fn) => {
                    return array.map(fn);
                },
                FILTER: (array, fn) => {
                    return array.filter(fn);
                },
                REDUCE: (array, fn, initial) => {
                    return array.reduce(fn, initial);
                },
                ABS: (x) => {
                    if (x instanceof Fraction) {
                        return new Fraction(Math.abs(x.numerator), x.denominator);
                    }
                    return Math.abs(x);
                },
                TO_STRING: (value) => {
                    return String(value);
                }
            },
            
            // 環境の初期化
            initEnvironment: function() {
                this.environment.global = {...this.standardFunctions};
                this.environment.current = this.environment.global;
            },
            
            // パイプライン演算子の処理
            processPipeline: function(left, right, env) {
                const leftValue = this.evaluateExpression(left, env);
                // rightは関数である必要がある
                if (typeof right === 'function') {
                    return right(leftValue);
                } else if (Array.isArray(right) && right.length >= 3 && right[1] === '(') {
                    // 関数呼び出し形式
                    const fnName = right[0];
                    const args = this.parseArguments(right.slice(2, -1));
                    
                    if (fnName in env) {
                        const fn = env[fnName];
                        if (typeof fn === 'function') {
                            // 第一引数として左辺の値を渡す
                            const evaluatedArgs = args.map(arg => this.evaluateExpression(arg, env));
                            return fn(leftValue, ...evaluatedArgs);
                        }
                    }
                }
                throw new Error(`パイプライン右辺が関数ではありません: ${JSON.stringify(right)}`);
            },
            
            // トークン化処理
            tokenize: function(code) {
                // # から始まるコメント行を処理
                code = code.replace(/#.*$/gm, '');
                
                // 正規表現を使って、コードを適切なトークンに分割
                const tokenRegex = /=>|\|>|>=|==|[A-Z][A-Z0-9_]*|[a-z][a-z0-9_]*|\d+\/\d+|\d+\.\d+|\d+|"[^"]*"|'[^']*'|\(|\)|\{|\}|\[|\]|,|;|\.|\+|\-|\*|\/|%|\?|:|>|=/g;
                const tokens = [];
                const lines = code.split('\n');
                
                for (const line of lines) {
                    let match;
                    const lineTokens = [];
                    const lineRegex = new RegExp(tokenRegex);
                    
                    while ((match = lineRegex.exec(line)) !== null) {
                        const token = match[0];
                        lineTokens.push(token);
                    }
                    
                    if (lineTokens.length > 0) {
                        tokens.push(lineTokens);
                    }
                }
                
                return tokens;
            },
            
            // 式の評価
            evaluateExpression: function(expr, env) {
                if (typeof expr === 'number') {
                    return new Fraction(expr);
                }
                
                if (typeof expr === 'string') {
                    // 変数参照
                    if (/^[A-Z][A-Z0-9_]*$/.test(expr)) {
                        if (expr in env) {
                            return env[expr];
                        }
                        throw new Error(`変数 '${expr}' は定義されていません`);
                    }
                    
                    // 文字列リテラル
                    if (expr.startsWith('"') && expr.endsWith('"')) {
                        return expr.slice(1, -1);
                    }
                    
                    // 分数リテラル
                    if (/^\d+\/\d+$/.test(expr)) {
                        const [numerator, denominator] = expr.split('/').map(Number);
                        return new Fraction(numerator, denominator);
                    }
                    
                    // 整数リテラル
                    if (/^\d+$/.test(expr)) {
                        return new Fraction(Number(expr));
                    }
                }
                
                if (Array.isArray(expr)) {
                    // パイプライン演算子
                    const pipeIndex = expr.indexOf('|>');
                    if (pipeIndex !== -1) {
                        const left = expr.slice(0, pipeIndex);
                        const right = expr.slice(pipeIndex + 1);
                        return this.processPipeline(left, right, env);
                    }
                    
                    // 関数呼び出し
                    if (expr.length >= 3 && expr[1] === '(') {
                        const fnName = expr[0];
                        const args = this.parseArguments(expr.slice(2, -1));
                        
                        if (fnName in env) {
                            const fn = env[fnName];
                            if (typeof fn === 'function') {
                                const evaluatedArgs = args.map(arg => this.evaluateExpression(arg, env));
                                return fn(...evaluatedArgs);
                            }
                        }
                        throw new Error(`関数 '${fnName}' は定義されていないか、呼び出し可能ではありません`);
                    }
                    
                    // 代入
                    if (expr.length >= 3 && expr[1] === '=>') {
                        const varName = expr[0];
                        // Types as Commentsの型情報をスキップ
                        let typeInfo = null;
                        let valueExpr;
                        
                        if (varName.includes(':')) {
                            const parts = varName.split(':');
                            // 最初の部分が変数名、2番目以降が型情報
                            varName = parts[0].trim();
                            typeInfo = parts.slice(1).join(':').trim();
                        }
                        
                        valueExpr = expr.slice(2);
                        const value = this.evaluateExpression(valueExpr, env);
                        
                        // 変数名は大文字のみ許可
                        if (!/^[A-Z][A-Z0-9_]*$/.test(varName)) {
                            throw new Error(`変数名は大文字で始まる必要があります: ${varName}`);
                        }
                        
                        env[varName] = value;
                        return value;
                    }
                    
                    // 二項演算
                    if (expr.length === 3) {
                        const left = this.evaluateExpression(expr[0], env);
                        const operator = expr[1];
                        const right = this.evaluateExpression(expr[2], env);
                        
                        return this.applyOperator(left, operator, right);
                    }
                    
                    // 条件式 (三項演算子)
                    if (expr.length === 5 && expr[3] === '?') {
                        const condition = this.evaluateExpression(expr.slice(0, 3), env);
                        return condition ? this.evaluateExpression(expr[4], env) : this.evaluateExpression(expr[6], env);
                    }
                }
                
                throw new Error(`無効な式です: ${JSON.stringify(expr)}`);
            },
            
            // 演算子の適用
            applyOperator: function(left, operator, right) {
                switch (operator) {
                    case '+':
                        if (typeof left === 'string' || typeof right === 'string') {
                            return String(left) + String(right);
                        }
                        if (left instanceof Fraction && right instanceof Fraction) {
                            return left.add(right);
                        }
                        return left + right;
                    
                    case '-':
                        if (left instanceof Fraction && right instanceof Fraction) {
                            return left.subtract(right);
                        }
                        return left - right;
                    
                    case '*':
                        if (left instanceof Fraction && right instanceof Fraction) {
                            return left.multiply(right);
                        }
                        return left * right;
                    
                    case '/':
                        if (right === 0 || (right instanceof Fraction && right.numerator === 0)) {
                            throw new Error("ゼロによる除算はできません");
                        }
                        if (typeof left === 'number' && typeof right === 'number') {
                            return new Fraction(left, right);
                        }
                        if (left instanceof Fraction && right instanceof Fraction) {
                            return left.divide(right);
                        }
                        return left / right;
                    
                    case '%':
                        if (right === 0 || (right instanceof Fraction && right.numerator === 0)) {
                            throw new Error("ゼロによる剰余演算はできません");
                        }
                        if (left instanceof Fraction && right instanceof Fraction) {
                            // 分数の剰余演算は複雑なので、数値に変換して計算
                            return new Fraction(left.toNumber() % right.toNumber());
                        }
                        return left % right;
                    
                    case '>':
                        if (left instanceof Fraction && right instanceof Fraction) {
                            return left.greaterThan(right);
                        }
                        return left > right;
                    
                    case '>=':
                        if (left instanceof Fraction && right instanceof Fraction) {
                            return left.greaterThan(right) || left.equals(right);
                        }
                        return left >= right;
                    
                    case '==':
                        if (left instanceof Fraction && right instanceof Fraction) {
                            return left.equals(right);
                        }
                        return left === right;
                    
                    default:
                        throw new Error(`サポートされていない演算子です: ${operator}`);
                }
            },
            
            // 引数のパース
            parseArguments: function(tokens) {
                const args = [];
                let currentArg = [];
                let level = 0;
                
                for (const token of tokens) {
                    if (token === ',' && level === 0) {
                        if (currentArg.length > 0) {
                            args.push(currentArg.length === 1 ? currentArg[0] : currentArg);
                            currentArg = [];
                        }
                    } else {
                        if (token === '(' || token === '[' || token === '{') {
                            level++;
                        } else if (token === ')' || token === ']' || token === '}') {
                            level--;
                        }
                        currentArg.push(token);
                    }
                }
                
                if (currentArg.length > 0) {
                    args.push(currentArg.length === 1 ? currentArg[0] : currentArg);
                }
                
                return args;
            },
            
            // 関数定義の処理
            // 関数定義の処理
            parseFunctionDefinition: function(tokens, env) {
                // 形式: FUNCNAME: (type) => type => (arg) => expr
                const funcName = tokens[0].split(':')[0]; // 型情報があれば分離
                const argsStart = tokens.indexOf('(');
                const argsEnd = this.findMatchingBracket(tokens, argsStart, '(', ')');
                const arrowIndex = tokens.indexOf('=>', argsEnd + 1);
                const bodyStart = tokens.indexOf('{', arrowIndex + 1);
                
                let bodyEnd;
                if (bodyStart !== -1) {
                    bodyEnd = this.findMatchingBracket(tokens, bodyStart, '{', '}');
                } else {
                    // 単一式の関数の場合は括弧がない
                    bodyEnd = tokens.length - 1;
                }
                
                if (argsStart === -1 || argsEnd === -1 || arrowIndex === -1) {
                    throw new Error(`関数定義の構文が無効です: ${tokens.join(' ')}`);
                }
                
                const argTokens = tokens.slice(argsStart + 1, argsEnd);
                const argNames = this.parseArguments(argTokens).map(arg => {
                    if (typeof arg === 'string' && /^[A-Z][A-Z0-9_]*$/.test(arg)) {
                        return arg;
                    }
                    throw new Error(`関数引数名が無効です: ${arg}`);
                });
                
                const bodyTokens = bodyStart !== -1 
                    ? tokens.slice(bodyStart + 1, bodyEnd)
                    : tokens.slice(arrowIndex + 1);
                
                // 関数を定義
                env[funcName] = (...args) => {
                    const localEnv = Object.create(env);
                    for (let i = 0; i < argNames.length; i++) {
                        localEnv[argNames[i]] = args[i];
                    }
                    
                    return this.evaluateStatements(bodyTokens, localEnv);
                };
                
                return env[funcName];
            },
            
            // 対応する括弧を見つける
            findMatchingBracket: function(tokens, start, open, close) {
                let level = 1;
                for (let i = start + 1; i < tokens.length; i++) {
                    if (tokens[i] === open) level++;
                    else if (tokens[i] === close) {
                        level--;
                        if (level === 0) return i;
                    }
                }
                return -1;
            },
            
            // 文の評価
            evaluateStatements: function(tokens, env) {
                let result;
                let index = 0;
                
                while (index < tokens.length) {
                    const statementEnd = this.findStatementEnd(tokens, index);
                    if (statementEnd === -1) break;
                    
                    const statement = tokens.slice(index, statementEnd + 1);
                    result = this.evaluateStatement(statement, env);
                    
                    index = statementEnd + 1;
                }
                
                return result;
            },
            
            // 文の終わりを見つける
            findStatementEnd: function(tokens, start) {
                let level = 0;
                for (let i = start; i < tokens.length; i++) {
                    const token = tokens[i];
                    if (token === '(' || token === '[' || token === '{') {
                        level++;
                    } else if (token === ')' || token === ']' || token === '}') {
                        level--;
                    } else if (token === ';' && level === 0) {
                        return i;
                    }
                }
                return tokens.length - 1;
            },
            
            // 単一の文を評価
            evaluateStatement: function(tokens, env) {
                if (tokens.length === 0) return undefined;
                
                // return 文
                if (tokens[0] === 'return') {
                    return this.evaluateExpression(tokens.slice(1), env);
                }
                
                // 関数定義
                if (tokens.length >= 5 && /^[A-Z][A-Z0-9_]*$/.test(tokens[0]) && tokens[1] === '=>') {
                    return this.parseFunctionDefinition(tokens, env);
                }
                
                // 変数代入
                if (tokens.length >= 3 && /^[A-Z][A-Z0-9_]*$/.test(tokens[0].split(':')[0]) && tokens[1] === '=>') {
                    const varName = tokens[0].split(':')[0]; // 型情報があれば分離
                    const value = this.evaluateExpression(tokens.slice(2), env);
                    env[varName] = value;
                    return value;
                }
                
                // 式の評価
                return this.evaluateExpression(tokens, env);
            },
            
            // パース処理の入り口
            parse: function(code) {
                try {
                    const tokens = this.tokenize(code);
                    return tokens;
                } catch (error) {
                    throw new Error(`パースエラー: ${error.message}`);
                }
            },
            
            // 実行処理の入り口
            execute: function(code) {
                try {
                    this.initEnvironment();
                    console.log("実行コード:", code);
                    
                    // FizzBuzz のショートカット (デモ用)
                    if (code.includes("FIZZBUZZ")) {
                        let maxNum = 20;
                        const match = code.match(/FIZZBUZZ\s*\(\s*(\d+)\s*\)/);
                        if (match && match[1]) {
                            maxNum = parseInt(match[1], 10);
                            if (maxNum > 1000) maxNum = 1000;
                        }
                        const result = [];
                        for (let i = 1; i <= maxNum; i++) {
                            if (i % 15 === 0) result.push("FizzBuzz");
                            else if (i % 3 === 0) result.push("Fizz");
                            else if (i % 5 === 0) result.push("Buzz");
                            else result.push(i.toString());
                        }
                        return result.join(", ");
                    }
                    
                    // 簡易実行 (デモ用)
                    if (code.includes("PRINT")) {
                        const match = code.match(/PRINT\s*\(\s*["'](.*)["']\s*\)/);
                        if (match && match[1]) return match[1];
                    }
                    
                    // 本格的なパースと実行
                    const tokens = this.parse(code);
                    if (tokens.length > 0) {
                        const result = this.evaluateStatements(tokens.flat(), this.environment.current);
                        return result !== undefined ? String(result) : "実行完了";
                    }
                    
                    return "実行完了";
                } catch (error) {
                    return `エラー: ${error.message}`;
                }
            }
        };

        // --- DOM Elements (Constants) ---
        const elements = {
            dotGrid: document.getElementById('dot-grid'),
            specialRow: document.getElementById('special-row'),
            lineCanvas: document.getElementById('line-canvas'),
            input: document.getElementById('txt-input'),
            d2dArea: document.getElementById('d2d-input'),
            output: document.getElementById('output'),
            executeButton: document.getElementById('execute-button'),
            outputSection: document.getElementById('output-section'),
            textSection: document.getElementById('text-section')
        };
        const lineCtx = elements.lineCanvas.getContext('2d');

        // --- Gesture State (Mutable) ---
        const drawState = {
            isActive: false,
            detectedDots: new Set(),
            totalValue: 0,
            startX: 0,
            startY: 0,
            lastStrokeTime: 0,
            lastDetectionTime: 0,
            currentStrokeDetected: false,
            strokeTimer: null,
            longPressTimer: null,
            isLongPress: false,
            currentTouchId: null,
            pointerStartTime: 0,
            pointerStartX: 0,
            pointerStartY: 0
        };

        const specialButtonState = {
            lastClickTime: 0,
            clickCount: 0,
            clickTarget: null,
            clickTimer: null,
            doubleClickDelay: 300,
        };

        const keyState = {
            deletePressed: false,
            spacePressed: false,
            lastPressTime: 0,
            maxTimeDiff: 300
        };

        // --- Utility Functions ---
        const insertAtCursor = (text) => {
            const textarea = elements.input;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const textBefore = textarea.value.substring(0, start);
            const textAfter = textarea.value.substring(end);
            textarea.value = textBefore + text + textAfter;
            const newCursorPos = start + text.length;
            textarea.selectionStart = textarea.selectionEnd = newCursorPos;
            if (window.innerWidth <= 768) showTextSection();
            textarea.focus();
        };

        const showTextSection = () => {
            if (window.innerWidth <= 768) {
                elements.outputSection.classList.add('hide');
                elements.textSection.classList.remove('hide');
            }
        };

        const showOutputSection = () => {
            if (window.innerWidth <= 768) {
                elements.textSection.classList.add('hide');
                elements.outputSection.classList.remove('hide');
            }
        };

        // --- Canvas Drawing Functions ---
        const clearCanvas = () => {
            lineCtx.clearRect(0, 0, elements.lineCanvas.width, elements.lineCanvas.height);
        };

        const updateCanvas = () => {
            const canvas = elements.lineCanvas;
            const ctx = lineCtx;
            const grid = elements.dotGrid;
            if (!grid || !canvas) return;
            const gridRect = grid.getBoundingClientRect();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const numericDotsToConnect = [];
            drawState.detectedDots.forEach(dot => {
                if (dot.classList.contains('numeric')) numericDotsToConnect.push(dot);
            });

            if (numericDotsToConnect.length < 1) return;

            ctx.beginPath();
            ctx.strokeStyle = CONFIG.visual.lineColor;
            ctx.lineWidth = CONFIG.visual.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            let isFirst = true;
            numericDotsToConnect.forEach(dot => {
                const rect = dot.getBoundingClientRect();
                const x = (rect.left - gridRect.left) + rect.width / 2;
                const y = (rect.top - gridRect.top) + rect.height / 2;
                if (isFirst) ctx.moveTo(x, y), isFirst = false;
                else ctx.lineTo(x, y);
            });

            if (!isFirst) ctx.stroke();
        };

        // --- Gesture Logic Functions ---
        const resetDrawState = (keepActive = false) => {
            drawState.isActive = keepActive;
            drawState.detectedDots.forEach(dot => dot.classList.remove('detected'));
            drawState.detectedDots.clear();
            drawState.totalValue = 0;
            drawState.isLongPress = false;
            drawState.currentStrokeDetected = false;
            if (!keepActive) drawState.lastStrokeTime = 0;
            clearTimeout(drawState.longPressTimer);
            clearTimeout(drawState.strokeTimer);
            drawState.longPressTimer = drawState.strokeTimer = null;
        };

        const recognizeLetter = (totalValue) => {
            const recognized = letterPatterns[totalValue] || null;
            if (recognized && CONFIG.debug) debugLog(`認識: 値=${totalValue}, 文字=${recognized}`);
            else if (CONFIG.debug) debugLog(`認識失敗: 値=${totalValue}`);
            return recognized;
        };

        const endDrawing = () => {
            if (!drawState.isActive) return;
            const now = Date.now();
            drawState.lastStrokeTime = now;

            if (drawState.currentStrokeDetected) {
                drawState.currentStrokeDetected = false;
                drawState.strokeTimer = setTimeout(() => {
                    if (Date.now() - drawState.lastStrokeTime >= CONFIG.timing.multiStrokeTimeout - 50) {
                        if (drawState.detectedDots.size > 0 && drawState.totalValue > 0) {
                            const rec = recognizeLetter(drawState.totalValue);
                            if (rec) {
                                insertAtCursor(rec);
                                const fb = document.createElement('div');
                                fb.className = 'recognition-feedback';
                                fb.textContent = rec;
                                elements.d2dArea.appendChild(fb);
                                setTimeout(() => fb.remove(), 800);
                            }
                        }
                        resetDrawState();
                        clearCanvas();
                    }
                }, CONFIG.timing.multiStrokeTimeout);
            }
        };

        const addDetectedDot = (dot) => {
            if (!dot || drawState.detectedDots.has(dot)) return;
            dot.classList.add('detected');
            drawState.detectedDots.add(dot);
            drawState.currentStrokeDetected = true;
            const v = parseInt(dot.dataset.value, 10);
            if (!isNaN(v)) drawState.totalValue += v;
            if (CONFIG.debug) debugLog(`ドット検出: index=${dot.dataset.index}, value=${v}, total=${drawState.totalValue}`);
        };

        const detectDot = (x, y) => {
            if (!drawState.isActive) return;
            const now = Date.now();
            if (now - drawState.lastDetectionTime < CONFIG.sensitivity.debounceTime) return;
            drawState.lastDetectionTime = now;

            document.querySelectorAll('#dot-grid .dot').forEach(dot => {
                if (drawState.detectedDots.has(dot)) return;
                const r = dot.getBoundingClientRect();
                const cx = r.left + r.width / 2;
                const cy = r.top + r.height / 2;
                const dist = Math.hypot(x - cx, y - cy);
                if (dist <= CONFIG.sensitivity.hitRadius) {
                    addDetectedDot(dot);
                }
            });

            updateCanvas();
        };

        const startDrawing = (dotEl, x, y) => {
            if (!dotEl || !dotEl.classList.contains('dot') || !dotEl.closest('#dot-grid')) return;
            const now = Date.now();
            if (!drawState.isActive || now - drawState.lastStrokeTime > CONFIG.timing.multiStrokeTimeout) {
                resetDrawState(true);
            }
            drawState.isActive = true;
            drawState.startX = x;
            drawState.startY = y;
            drawState.lastDetectionTime = now;
            addDetectedDot(dotEl);
            updateCanvas();
        };

        // --- Event Handlers ---
        const handleDeleteAction = (deleteToken = false) => {
            const ta = elements.input;
            const pos = ta.selectionStart;
            if (pos > 0) {
                let before = ta.value.substring(0, pos);
                const after = ta.value.substring(pos);
                if (deleteToken) {
                    const idx = before.lastIndexOf(' ');
                    before = idx >= 0 ? before.substring(0, idx + 1) : '';
                } else {
                    before = before.substring(0, before.length - 1);
                }
                ta.value = before + after;
                ta.selectionStart = ta.selectionEnd = before.length;
            }
            showTextSection();
            elements.input.focus();
        };

        const handleSpecialButtonClick = (e, type, actions) => {
            e.preventDefault();
            const now = Date.now();
            if (specialButtonState.clickTarget === type &&
                now - specialButtonState.lastClickTime < specialButtonState.doubleClickDelay) {
                clearTimeout(specialButtonState.clickTimer);
                specialButtonState.clickCount = 0;
                specialButtonState.clickTarget = null;
                actions.double();
                if (CONFIG.debug) debugLog(`ダブルクリック: ${type}`);
            } else {
                specialButtonState.clickCount = 1;
                specialButtonState.lastClickTime = now;
                specialButtonState.clickTarget = type;
                specialButtonState.clickTimer = setTimeout(() => {
                    if (specialButtonState.clickCount === 1) {
                        actions.single();
                        if (CONFIG.debug) debugLog(`シングルクリック: ${type}`);
                    }
                    specialButtonState.clickCount = 0;
                    specialButtonState.clickTarget = null;
                }, specialButtonState.doubleClickDelay);
            }
        };

        const handleSpecialButtonLongPress = (e, btn, action) => {
            e.preventDefault();
            const t = setTimeout(() => {
                action();
                btn.classList.add('long-pressed');
                if (CONFIG.debug) debugLog(`長押し: ${btn.dataset.action || btn.dataset.digit}`);
                setTimeout(() => btn.classList.remove('long-pressed'), 200);
            }, CONFIG.timing.longPressDuration);

            const clear = () => {
                clearTimeout(t);
                btn.removeEventListener('pointerup', clear);
                btn.removeEventListener('pointercancel', clear);
                btn.removeEventListener('pointerleave', clear);
            };
            btn.addEventListener('pointerup', clear);
            btn.addEventListener('pointercancel', clear);
            btn.addEventListener('pointerleave', clear);
        };

        const executeCode = () => {
            const code = elements.input.value;
            if (!code.trim()) return;
            try {
                const result = shikigamiInterpreter.execute(code);
                elements.output.value = result !== undefined ? result : "実行完了";
                elements.output.classList.add('executed');
                setTimeout(() => elements.output.classList.remove('executed'), 300);
                showOutputSection();
                if (!result.startsWith("エラー:")) elements.input.value = "";
                if (CONFIG.debug) debugLog(`コード実行: ${code.substring(0, 20)}${code.length > 20 ? '...' : ''}`);
            } catch (err) {
                elements.output.value = `エラー: ${err.message}`;
                showOutputSection();
                if (CONFIG.debug) debugLog(`実行エラー: ${err.message}`);
            }
        };

        const setupKeyboardHandlers = () => {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    keyState.deletePressed = true;
                }
                if ((e.key === ' ' || e.key === 'Spacebar') && document.activeElement !== elements.input) {
                    e.preventDefault();
                    keyState.spacePressed = true;
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') keyState.deletePressed = false;
                if (e.key === ' ' || e.key === 'Spacebar') keyState.spacePressed = false;
            });
        };

        const handlePointerUp = (e) => {
            if (e.pointerId !== drawState.currentTouchId) return;
            e.preventDefault();
            const el = document.querySelector(`[data-pointer-id="${e.pointerId}"]`);
            if (el?.hasPointerCapture(e.pointerId)) {
                try { el.releasePointerCapture(e.pointerId); delete el.dataset.pointerId; }
                catch (err) { console.error("Error releasing pointer capture on up:", err); }
            }
            clearTimeout(drawState.longPressTimer);
            if (drawState.isActive && !drawState.isLongPress) endDrawing();
            else if (drawState.isLongPress) {
                resetDrawState();
                clearCanvas();
            }
            drawState.currentTouchId = null;
        };

        const handlePointerMove = (e) => {
            if (!drawState.isActive || e.pointerId !== drawState.currentTouchId) return;
            e.preventDefault();
            const dx = e.clientX - drawState.pointerStartX;
            const dy = e.clientY - drawState.pointerStartY;
            if (Math.hypot(dx, dy) >= CONFIG.sensitivity.minSwipeDistance) {
                clearTimeout(drawState.longPressTimer);
                drawState.longPressTimer = null;
                detectDot(e.clientX, e.clientY);
            }
        };

        const handlePointerDown = (e, el) => {
            e.preventDefault();
            if (el.hasPointerCapture(e.pointerId)) return;
            try { el.setPointerCapture(e.pointerId); el.dataset.pointerId = e.pointerId; }
            catch (err) { console.error("Error setting pointer capture:", err); }

            showTextSection();
            drawState.isLongPress = false;
            drawState.currentTouchId = e.pointerId;
            drawState.pointerStartTime = Date.now();
            drawState.pointerStartX = e.clientX;
            drawState.pointerStartY = e.clientY;

            const digit = el.dataset.digit;
            const word = el.dataset.word;
            if (digit || word) {
                clearTimeout(drawState.longPressTimer);
                drawState.longPressTimer = setTimeout(() => {
                    const dist = Math.hypot(e.clientX - drawState.pointerStartX, e.clientY - drawState.pointerStartY);
                    if (dist < CONFIG.sensitivity.minSwipeDistance && (!drawState.isActive || drawState.detectedDots.size <= 1)) {
                        insertAtCursor(digit || word);
                        drawState.isLongPress = true;
                        resetDrawState();
                        clearCanvas();
                        if (CONFIG.debug) debugLog(`長押し入力: ${digit || word}`);
                    }
                }, CONFIG.timing.longPressDuration);
            }

            if (el.closest('#dot-grid')) startDrawing(el, e.clientX, e.clientY);
        };

        // --- Event Listener Setup ---
        const setupDotEventListeners = () => {
            document.querySelectorAll('#dot-grid .dot').forEach(dot => {
                dot.addEventListener('pointerdown', e => handlePointerDown(e, dot), { passive: false });
            });
        };

        const setupSpecialButtonListeners = () => {
            const deleteBtn = elements.specialRow.querySelector('[data-action="delete"]');
            const zeroBtn   = elements.specialRow.querySelector('[data-digit="0"]');
            const spaceBtn  = elements.specialRow.querySelector('[data-action="space"]');

            if (deleteBtn) {
                deleteBtn.addEventListener('click', e => handleSpecialButtonClick(e, 'delete', {
                    single: () => handleDeleteAction(false),
                    double: () => handleDeleteAction(true),
                    long:   () => {}
                }));
                deleteBtn.addEventListener('pointerdown', e => handleSpecialButtonLongPress(e, deleteBtn, () => {}));
            }

            if (zeroBtn) {
                zeroBtn.addEventListener('click', e => handleSpecialButtonClick(e, 'zero', {
                    single: () => insertAtCursor('0'),
                    double: () => {},
                    long:   () => {}
                }));
                zeroBtn.addEventListener('pointerdown', e => handleSpecialButtonLongPress(e, zeroBtn, () => {}));
            }

            if (spaceBtn) {
                spaceBtn.addEventListener('click', e => handleSpecialButtonClick(e, 'space', {
                    single: () => insertAtCursor(' '),
                    double: () => insertAtCursor('\n'),
                    long:   () => {}
                }));
                spaceBtn.addEventListener('pointerdown', e => handleSpecialButtonLongPress(e, spaceBtn, () => {}));
            }

            // setupCombinedButtonPress関数の呼び出しを削除
        };

        const setupExecuteButtonListener = () => {
            elements.executeButton.addEventListener('click', executeCode);
        };

        const resizeCanvas = () => {
            const rect = elements.d2dArea.getBoundingClientRect();
            const style = window.getComputedStyle(elements.d2dArea);
            const pl = parseFloat(style.paddingLeft);
            const pt = parseFloat(style.paddingTop);
            elements.lineCanvas.width  = elements.d2dArea.clientWidth  - pl * 2;
            elements.lineCanvas.height = elements.d2dArea.clientHeight - pt * 2;
            elements.lineCanvas.style.left = `${pl}px`;
            elements.lineCanvas.style.top  = `${pt}px`;
            updateCanvas();
        };

        const setupGestureListeners = () => {
            document.addEventListener('pointermove', handlePointerMove, { passive: false });
            document.addEventListener('pointerup',   handlePointerUp,   { passive: false });
            document.addEventListener('pointercancel', handlePointerUp,  { passive: false });
        };

        // --- Debug Interface & Helpers ---
        const debugLog = (msg) => {
            if (!CONFIG.debug) return;
            const out = document.getElementById('debug-output');
            if (!out) return;
            const e = document.createElement('div');
            e.textContent = `${new Date().toLocaleTimeString()}: ${msg}`;
            out.prepend(e);
            while (out.children.length > 10) out.removeChild(out.lastChild);
        };

        const addSliderControl = (parent, id, label, min, max, val, onChange) => {
            const c = document.createElement('div'); c.className = 'control-container';
            const l = document.createElement('label'); l.htmlFor = `control-${id}`; l.textContent = `${label}: `;
            const s = document.createElement('input'); s.type = 'range'; s.id = `control-${id}`; s.min = min; s.max = max; s.value = val;
            const v = document.createElement('span'); v.className = 'value-display'; v.textContent = val;
            s.addEventListener('input', () => { v.textContent = s.value; onChange(s.value); });
            c.appendChild(l); c.appendChild(s); c.appendChild(v);
            parent.appendChild(c);
        };

        const updateConfigStyles = () => {
            const existing = document.getElementById('dynamic-config-styles');
            if (existing) existing.remove();
            const s = document.createElement('style'); s.id = 'dynamic-config-styles';
            s.textContent = `
                .dot {
                    width: ${CONFIG.layout.dotSize}px;
                    height: ${CONFIG.layout.dotSize}px;
                }
                .dot.detected {
                    background-color: ${CONFIG.visual.detectedColor};
                }
                #line-canvas { pointer-events: none; }
            `;
            document.head.appendChild(s);
        };

        const setupDebugInterface = () => {
            if (!CONFIG.debug || window.innerWidth <= 768) return;
            const section = document.createElement('section');
            section.id = 'debug-panel';
            const h2 = document.createElement('h2'); h2.textContent = 'debug controls';
            section.appendChild(h2);

            addSliderControl(section, 'hitRadius', 'Hit Radius', 5, 50, CONFIG.sensitivity.hitRadius, v => CONFIG.sensitivity.hitRadius = Number(v));
            addSliderControl(section, 'minSwipe', 'Min Swipe', 1, 20, CONFIG.sensitivity.minSwipeDistance, v => CONFIG.sensitivity.minSwipeDistance = Number(v));
            addSliderControl(section, 'multiStroke', 'Multi-Stroke Timeout', 100, 2000, CONFIG.timing.multiStrokeTimeout, v => { CONFIG.timing.multiStrokeTimeout = Number(v); });
            addSliderControl(section, 'longPress', 'Long Press Duration', 100, 1000, CONFIG.timing.longPressDuration, v => CONFIG.timing.longPressDuration = Number(v));
            addSliderControl(section, 'debounce', 'Debounce Time', 10, 200, CONFIG.sensitivity.debounceTime, v => CONFIG.sensitivity.debounceTime = Number(v));
            addSliderControl(section, 'dotSize', 'Dot Size', 30, 80, CONFIG.layout.dotSize, v => { CONFIG.layout.dotSize = Number(v); updateConfigStyles(); initKeypad(); });
            addSliderControl(section, 'dotGap', 'Dot Gap', 5, 30, CONFIG.layout.dotGap, v => { CONFIG.layout.dotGap = Number(v); updateConfigStyles(); initKeypad(); });

            const sampleCodes = {
                'FizzBuzz': `# FizzBuzz サンプル
FIZZBUZZ => (MAX) => {
    RESULT => []
    RANGE(1, MAX).forEach((X) => {
        OUTPUT => 
            X % 15 == 0 ? "FizzBuzz"
            : X % 3 == 0 ? "Fizz"
            : X % 5 == 0 ? "Buzz"
            : X.toString()
        RESULT.push(OUTPUT)
    })
    RESULT
}
PRINT(FIZZBUZZ(20).join(", "))`,
                '計算例': `# 分数計算
A => 3/4
B => 1/2
SUM => A + B
PRINT("合計: " + SUM)

# 配列処理
NUMBERS => [1, 2, 3, 4, 5]
DOUBLED => NUMBERS |> MAP((X) => X * 2)
PRINT(DOUBLED)`
            };
            const btnContainer = document.createElement('div');
            btnContainer.style.display = 'flex';
            btnContainer.style.gap = '10px';
            btnContainer.style.marginBottom = '10px';
            for (const [name, code] of Object.entries(sampleCodes)) {
                const btn = document.createElement('button');
                btn.textContent = name;
                btn.style.padding = '5px 10px';
                btn.style.border = '1px solid #ccc';
                btn.style.borderRadius = '4px';
                btn.style.cursor = 'pointer';
                btn.addEventListener('click', () => { elements.input.value = code; });
                btnContainer.appendChild(btn);
            }
            section.appendChild(btnContainer);

            const debugOut = document.createElement('div');
            debugOut.id = 'debug-output';
            debugOut.className = 'debug-output';
            section.appendChild(debugOut);

            document.querySelector('article').appendChild(section);
        };

        const initResponsiveLayout = () => {
            window.addEventListener('resize', () => {
                if (window.innerWidth <= 768) {
                    const dp = document.getElementById('debug-panel');
                    if (dp) dp.style.display = 'none';
                } else {
                    const dp = document.getElementById('debug-panel');
                    if (dp && CONFIG.debug) dp.style.display = 'block';
                    elements.outputSection.classList.remove('hide');
                    elements.textSection.classList.remove('hide');
                }
                resizeCanvas();
            });
            if (window.innerWidth <= 768) {
                elements.outputSection.classList.add('hide');
                elements.textSection.classList.remove('hide');
            }
        };

        // --- ドット配置の設定 ---
        const dotValues = [
            1, 2, 4, 8, 16, 32, 64, 128, 256, 512,
            1024, 2048, 4096, 8192, 16384, 32768,
            65536, 131072, 262144, 524288, 1048576,
            2097152, 4194304, 8388608, 16777216
        ];
        const letterPatterns = {
            17836036: 'A', 28611899: 'B', 32539711: 'C', 1224985: 'D',
            32567296: 'E', 1113151: 'F', 33092671: 'G', 18415153: 'H',
            32641183: 'I', 7475359: 'J', 17990833: 'K', 32539681: 'L',
            18405233: 'M', 18667121: 'N', 33080895: 'O', 1113663: 'P',
            33347135: 'Q', 18153023: 'R', 33061951: 'S', 4329631:  'T',
            33080881: 'U', 4204561: 'V', 18732593: 'W', 18157905: 'X',
            4329809:  'Y', 32575775: 'Z'
        };
        const numericPositions = {
            0: '1', 2: '2', 4: '3',
            10: '4', 12: '5', 14: '6',
            20: '7', 22: '8', 24: '9'
        };
        const dotWordMapping = {
            2: '未定', 8: '未定',
            32: '(', 64: ')', 128: '+', 256: '{', 512: '}',
            2048: '*', 8192: '/',
            32768: '未定', 65536: '未定', 131072: '-', 262144: '未定', 524288: '未定',
            2097152: '>', 8388608: '='
        };

        // --- Keypad Initialization ---
        function initKeypad() {
            elements.dotGrid.innerHTML = '';
            elements.specialRow.innerHTML = '';
            elements.dotGrid.style.gap = `${CONFIG.layout.dotGap}px`;

            for (let r = 0; r < CONFIG.layout.gridRows; r++) {
                const row = document.createElement('div');
                row.className = 'dot-row';
                row.style.gap = `${CONFIG.layout.dotGap}px`;
                for (let c = 0; c < CONFIG.layout.gridCols; c++) {
                    const idx = r * CONFIG.layout.gridCols + c;
                    const value = dotValues[idx];
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    dot.dataset.index = idx;
                    dot.dataset.value = value;
                    dot.style.width = `${CONFIG.layout.dotSize}px`;
                    dot.style.height = `${CONFIG.layout.dotSize}px`;

                    const digit = numericPositions[idx];
                    const word  = dotWordMapping[value];
                    if (digit) {
                        dot.classList.add('numeric');
                        dot.textContent = digit;
                        dot.dataset.digit = digit;
                    } else if (word) {
                        dot.classList.add('word-dot');
                        dot.textContent = word;
                        dot.dataset.word = word;
                    } else {
                        dot.textContent = '未定';
                    }
                    row.appendChild(dot);
                }
                elements.dotGrid.appendChild(row);
            }

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'special-button delete';
            deleteBtn.textContent = 'DELETE';
            deleteBtn.dataset.action = 'delete';
            deleteBtn.title = '削除';
            elements.specialRow.appendChild(deleteBtn);

            const zeroBtn = document.createElement('div');
            zeroBtn.className = 'dot numeric';
            zeroBtn.textContent = '0';
            zeroBtn.dataset.digit = '0';
            elements.specialRow.appendChild(zeroBtn);

            const spaceBtn = document.createElement('div');
            spaceBtn.className = 'special-button space';
            spaceBtn.textContent = 'SPACE';
            spaceBtn.dataset.action = 'space';
            spaceBtn.title = '空白';
            elements.specialRow.appendChild(spaceBtn);

            elements.d2dArea.tabIndex = -1;

            elements.input.addEventListener('focus', e => {
                if (!e.isTrusted) elements.d2dArea.focus();
            });
            elements.d2dArea.addEventListener('touchstart', () => {
                if (document.activeElement === elements.input) elements.d2dArea.focus();
                showTextSection();
            });

            updateConfigStyles();
            resizeCanvas();

            setupDotEventListeners();
            setupSpecialButtonListeners();
            setupGestureListeners();
        }

        // --- Initialization on load ---
        window.onload = () => {
            initKeypad();
            initResponsiveLayout();
            setupDebugInterface();
            setupExecuteButtonListener();
            setupKeyboardHandlers();
            
            // 自動フォーマット機能の初期化
            codeFormatter.setupAutoFormat(elements.input);
        };
    </script>
</body>

</html>